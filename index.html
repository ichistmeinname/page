<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>M.Sc. Sandra Dylus - index</title>
<link rel="stylesheet" type="text/css" href="./css/default.css">
</head>
<body>
<div id="header">
<div id="logo">
  <a href="./"><your logo here></a>
</div>
<div id="navigation">
  <a href="#top">Top</a>
  <a href="#aboutme">About Me</a>
  <a href="#research">Research</a>
  <a href="#publications">Publications</a>
  <a href="#teaching">Teaching</a>
</div>
</div>
<div id="content">
<div id="top" class="top">
<div class="picture">
<img src="images/picture-square.png" />
</div>
<div class="social">
<a href="https://twitter.com/ichistmeinname"></a>
<div class="twitter">

</div>
</a> <a href="https://github.com/ichistmeinname"></a>
<div class="github">

</div>
</a> <a href="https://www.linkedin.com/in/sandra-dylus-4874a48b/"></a>
<div class="linkedin">

</div>
</a> <a href="https://www.researchgate.net/profile/Sandra_Dylus"></a>
<div class="researchgate">

</div>
</a> <a href="https://www.researchgate.net/profile/Sandra_Dylus"></a>
<div class="keybase">

</div>
</a>
</div>
</div>
<span class="math inline">
  <div class="section aboutme" id="aboutme">
  <div class="left-column">
    <h2>About me</h2>
  </div>

<div class="column aboutme">
  

    Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.

  
</div>
</div>

  <div class="section research" id="research">
  <div class="left-column">
    <h2>Research</h2>
  </div>

<div class="column research">
  

    Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.

  
</div>
</div>

  <div class="section publications" id="publications">
  <div class="left-column">
    <h2>Publications</h2>
  </div>

<div class="column publications">
  

  <ul>
    
    <li>
    <strong>Verifying Effectful Haskell Programs in Coq</strong>
    <input class="pub abstract" id="abstractVerifying" type="checkbox" d>
    <label for="abstractVerifying"><button>Preprint</button></label>
    <input class="pub bib" id="bibVerifying" type="checkbox" d>
    <label for="bibVerifying"><button>BibTex</button></label>
    <br>
    <a href="https://icfp19.sigplan.org/home/haskellsymp-2019#event-overview">Haskell Symposium 2019</a>
    
    <i>(acceptance ratio 13/25)</i>
    
    <br>
    with Jan Christiansen, and Niels Bunkenburg
    </br>
    </br>
    <div id="abstractExpand" class="expand abstract">
<p>We show how various Haskell language features that are related to ambient e ects can be modeled in Coq. For this purpose we build on previous work that demonstrates how to reason about existing Haskell programs by translating them into monadic Coq programs. A model of Haskell programs in Coq that is polymorphic over an arbitrary monad results in non-strictly positive types when transforming recursive data types likes lists. Such non-strictly positive types are not accepted by Coq’s termination checker. Therefore, instead of a model that is generic over any monad, the approach we build on uses a specific monad instance, namely the free monad in combination with containers, to model various kinds of e ects. This model allows effect-generic proofs. </br> In this paper we consider ambient effects that may occur in Haskell, namely partiality, errors, and tracing, in detail. We observe that, while proving propositions that hold for all kinds of effects is attractive, not all propositions of interest hold for all kinds of effects. Some propositions fail for certain e ects because the usual monadic translation models call-by-name and not call-by-need. Since modeling the evaluation semantics of call-by-need in the presence of e ects like partiality is complex and not necessary to prove propositions for a variety of effects, we identify a specific class of effects for which we cannot observe a di erence between call-by-name and call-by-need. Using this class of effects we can prove propositions for all effects that do not require a model of sharing.</p>
</div>
<!-- <div class="expand bib" id="bibExpand"> --> <!--   <pre> --> <!--     <code> --> <!--     @inproceedings{christiansen2019verifying --> <!--     author    = {Christiansen, Jan and Dylus, Sandra and Bunkenburg, Niels}, --> <!--     title     = {Verifying Effectful Haskell Programs in Coq}, --> <!--     booktitle = {Proceedings of the 12th International Symposium on Haskell}, --> <!--     series    = {ICFP 2019}, --> <!--     year      = {2019}, --> <!--     location  = {Berlin, Germany}, --> <!--     publisher = {ACM}, --> <!--     address   = {New York, NY, USA}, --> <!--     } --> <!--     </code> --> <!--   </pre> --> <!-- </div> -->
    </li>
    
    <li>
    <strong>Implementing a Library for Probabilistic Programming using Non-strict Non-determinism</strong>
    <input class="pub abstract" id="abstractImplementing" type="checkbox" d>
    <label for="abstractImplementing"><button>Preprint</button></label>
    <input class="pub bib" id="bibImplementing" type="checkbox" d>
    <label for="bibImplementing"><button>BibTex</button></label>
    <br>
    <a href="https://www.cambridge.org/core/journals/theory-and-practice-of-logic-programming">Journal on Theory and Practice of Logic Programming, July 2019</a>
    
    <br>
    with Jan Christiansen, and Finn Teegen
    </br>
    </br>
    <div id="abstractExpand" class="expand abstract">
<p>This paper presents PFLP, a library for probabilistic programming in the functional logic programming language Curry. It demonstrates how the concepts of a functional logic programming language support the implementation of a library for probabilistic programming. In fact, the paradigms of functional logic and probabilistic programming are closely connected. That is, language characteristics from one area exist in the other and vice versa. For example, the concepts of non-deterministic choice and call-time choice as known from functional logic programming are related to and coincide with stochastic memoization and probabilistic choice in probabilistic programming, respectively. </br> We will further see that an implementation based on the concepts of functional logic programming can have benefits with respect to performance compared to a standard list-based implementation and can even compete with full-blown probabilistic programming languages, which we illustrate by several benchmarks. Under consideration in Theory and Practice of Logic Programming (TPLP).</p>
</div>
<div id="bibExpand" class="expand bib">
<pre><code>    
    @article{dylus2019implementing,
    title     = {Implementing a Library for Probabilistic Programming Using Non-strict Non-determinism},
    DOI       = {10.1017/S1471068419000085},
    journal   = {Theory and Practice of Logic Programming},
    publisher = {Cambridge University Press},
    author    = {Dylus, Sandra and Christiansen, Jan and Teegen, Finn},
    pages     = {1–29}
    }
    
  </code></pre>
</div>
    </li>
    
    <li>
    <strong>One Monad To Prove Them All</strong>
    <input class="pub abstract" id="abstractMonad" type="checkbox" d>
    <label for="abstractMonad"><button>Preprint</button></label>
    <input class="pub bib" id="bibMonad" type="checkbox" d>
    <label for="bibMonad"><button>BibTex</button></label>
    <br>
    <a href="https://2019.programming-conference.org/track/programming-2019-papers#event-overview">Journal on the Art, Science, and Engineering ofProgramming, Volume 3, 2019</a>
    
    <br>
    with Jan Christiansen, and Finn Teegen
    </br>
    </br>
    <div id="abstractExpand" class="expand abstract">
<p>One Monad to Prove Them All is a modern fairy tale about curiosity and perseverance, two important properties of a successful PhD student. We follow the PhD student Mona on her adventure of proving properties about Haskell programs in the proof assistant Coq. </br> On the one hand, as a PhD student in computer science Mona observes an increasing demand for correct software products. In particular, because of the large amount of existing software, verifying existing software products becomes more important. Verifying programs in the functional programming language Haskell is no exception. On the other hand, Mona is delighted to see that communities in the area of theorem proving are becoming popular. Thus, Mona sets out to learn more about the interactive theorem prover Coq and verifying Haskell programs in Coq. </br> To prove properties about a Haskell function in Coq, Mona has to translate the function into Coq code. As Coq programs have to be total and Haskell programs are often not, Mona has to model partiality explicitly in Coq. In her quest for a solution Mona nds an ancient manuscript that explains how properties about Haskell functions can be proven in the proof assistant Agda by translating Haskell programs into monadic Agda programs. By instantiating the monadic program with a concrete monad instance the proof can be performed in either a total or a partial setting. Mona discovers that the proposed transformation does not work in Coq due to a restriction in the termination checker. In fact the transformation does not work in Agda anymore as well, as the termination checker in Agda has been improved. </br> We follow Mona on an educational journey through the land of functional programming where she learns about concepts like free monads and containers as well as basics and restrictions of proof assistants like Coq. These concepts are well-known individually, but their interplay gives rise to a solution for Mona’s problem based on the originally proposed monadic tranformation that has not been presented before. When Mona starts to test her approach by proving a statement about simple Haskell functions, she realizes that her approach has an additional advantage over the original idea in Agda. Mona’s final solution not only works for a speci c monad instance but even allows her to prove monad-generic properties. Instead of proving properties over and over again for speci c monad instances she is able to prove properties that hold for all monads representable by a container-based instance of the free monad. In order to strengthen her con dence in the practicability of her approach, Mona evaluates her approach in a case study that compares two implementations for queues. In order to share the results with other functional programmers the fairy tale is available as a literate Coq file. </br> If you are a citizen of the land of functional programming or are at least familiar with its customs, had a journey that involved reasoning about functional programs of your own, or are just a curious soul looking for the next story about monads and proofs, then this tale is for you.</p>
</div>
<div id="bibExpand" class="expand bib">
<pre><code>    
    @article{dylus2019One,
    author    = {Sandra Dylus and
                 Jan Christiansen and
                 Finn Teegen},
    title     = {One Monad to Prove Them All},
    journal   = {Programming Journal},
    volume    = {3},
    number    = {3},
    pages     = {8},
    year      = {2019},
    url       = {https://doi.org/10.22152/programming-journal.org/2019/3/8},
    doi       = {10.22152/programming-journal.org/2019/3/8},
    }
    
  </code></pre>
</div>
    </li>
    
    <li>
    <strong>Probabilistic Functional Logic Programming</strong>
    <input class="pub abstract" id="abstractPFLP" type="checkbox" d>
    <label for="abstractPFLP"><button>Preprint</button></label>
    <input class="pub bib" id="bibPFLP" type="checkbox" d>
    <label for="bibPFLP"><button>BibTex</button></label>
    <br>
    <a href="https://popl18.sigplan.org/track/PADL-2018#event-overview">International Symposium on Practical Aspects of Declarative Languages 2018</a>
    
    <i>(acceptance ratio 13/23)</i>
    
    <br>
    with Jan Christiansen, and Finn Teegen
    </br>
    </br>
    <div id="abstractExpand" class="expand abstract">
<p>This paper presents PFLP, a library for probabilistic programming in the functional logic programming language Curry. It demonstrates how the concepts of a functional logic programming language support the implementation of a library for probabilistic programming. </br> In fact, the paradigms of functional logic and probabilistic programming are closely connected. That is, we can apply techniques from one area to the other and vice versa. We will see that an implementation based on the concepts of functional logic programming can have benefits with respect to performance compared to a standard list-based implementation.</p>
</div>
<div id="bibExpand" class="expand bib">
<pre><code>    
    @inproceedings{dylus2018probabilistic,
    author    = {Dylus, Sandra and Christiansen, Jan and Teegen, Finn},
    editor    = {Calimeri, Francesco and Hamlen, Kevin and Leone, Nicola},
    title     = {Probabilistic Functional Logic Programming},
    booktitle = {Practical Aspects of Declarative Languages},
    year      = {2018},
    publisher = {Springer International Publishing},
    address   = {Cham},
    pages     = {3--19},
    isbn      = {978-3-319-73305-0}
    }
    
  </code></pre>
</div>
    </li>
    
    <li>
    <strong>All Sorts of Permutations (Functional Pearl)</strong>
    <input class="pub abstract" id="abstractSorts" type="checkbox" d>
    <label for="abstractSorts"><button>Preprint</button></label>
    <input class="pub bib" id="bibSorts" type="checkbox" d>
    <label for="bibSorts"><button>BibTex</button></label>
    <br>
    <a href="https://icfp16.sigplan.org/track/icfp-2016-papers#event-overview">International Conference on Functional Programming 2016</a>
    
    <i>(acceptance ratio 37/115)</i>
    
    <br>
    with Jan Christiansen, and Nikita Danilenko
    </br>
    </br>
    <div id="abstractExpand" class="expand abstract">
<p>The combination of non-determinism and sorting is mostly associated with permutation sort, a sorting algorithm that is not very useful for sorting and has an awful running time. In this paper we look at the combination of non-determinism and sorting in a different light: given a sorting function, we apply it to a non-deterministic predicate to gain a function that enumerates permutations of the input list. We get to the bottom of necessary properties of the sorting algorithms and predicates in play as well as discuss variations of the modelled non-determinism. </br> On top of that, we formulate and prove a theorem stating that no matter which sorting function we use, the corresponding permutation function enumerates all permutations of the input list. We use free theorems, which are derived from the type of a function alone, to prove the statement.</p>
</div>
<div id="bibExpand" class="expand bib">
<pre><code>    
    @inproceedings{christiansen2016sorts
    author    = {Christiansen, Jan and Danilenko, Nikita and Dylus, Sandra},
    title     = {All Sorts of Permutations (Functional Pearl)},
    booktitle = {Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming},
    series    = {ICFP 2016},
    year      = {2016},
    isbn      = {978-1-4503-4219-3},
    location  = {Nara, Japan},
    pages     = {168--179},
    numpages  = {12},
    url       = {http://doi.acm.org/10.1145/2951913.2951949},
    doi       = {10.1145/2951913.2951949},
    acmid     = {2951949},
    publisher = {ACM},
    address   = {New York, NY, USA},
    keywords  = {Haskell, free theorems, monads, non-determinism, permutation, sorting},
    }
    
  </code></pre>
</div>
    </li>
    
  </ul>

  
</div>
</div>

  <div class="section teaching" id="teaching">
  <div class="left-column">
    <h2>Teaching</h2>
  </div>

<div class="column teaching">
  

    Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.

  
</div>
</div>
</span>
<div id="footer">
  Site proudly generated by
  <a href="http://jaspervdj.be/hakyll">Hakyll</a>
</div>
</div>
</body>
</html>
